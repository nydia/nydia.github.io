<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nydia.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="开源，协作，共享，进步">
<meta property="og:type" content="website">
<meta property="og:title" content="Talk is cheap,show me the code">
<meta property="og:url" content="https://nydia.github.io/page/5/index.html">
<meta property="og:site_name" content="Talk is cheap,show me the code">
<meta property="og:description" content="开源，协作，共享，进步">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="nydia">
<meta property="article:tag" content="开源">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://nydia.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Talk is cheap,show me the code</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Talk is cheap,show me the code" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Talk is cheap,show me the code</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">开源，协作，共享，进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/en/architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/en/architecture/" class="post-title-link" itemprop="url">RocketMQ Architecture design</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:58:37" itemprop="dateModified" datetime="2025-04-26T20:58:37+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Architecture-design"><a href="#Architecture-design" class="headerlink" title="Architecture design"></a>Architecture design</h1><h2 id="Technology-Architecture"><a href="#Technology-Architecture" class="headerlink" title="Technology Architecture"></a>Technology Architecture</h2><p><img src="/image/rocketmq_architecture_1.png"></p>
<p>The RocketMQ architecture is divided into four parts, as shown in the figure above:</p>
<ul>
<li><p>Producer：The role of message publishing supports distributed cluster mode deployment. Producer selects the corresponding Broker cluster queue for message delivery through MQ’s load balancing module. The delivery process supports fast failure and low latency.</p>
</li>
<li><p>Consumer：The role of message consumption supports distributed cluster deployment. Support push, pull two modes to consume messages. It also supports cluster mode and broadcast mode consumption, and it provides a real-time message subscription mechanism to meet the needs of most users.</p>
</li>
<li><p>NameServer：NameServer is a very simple Topic routing registry with a role similar to ZooKeeper in Dubbo, which supports dynamic registration and discovery of Broker. It mainly includes two functions: Broker management, NameServer accepts the registration information of the Broker cluster and saves it as the basic data of the routing information. Then provide a heartbeat detection mechanism to check whether the broker is still alive; routing information management, each NameServer will save the entire routing information about the Broker cluster and the queue information for the client query. Then the Producer and Consumer can know the routing information of the entire Broker cluster through the NameServer, so as to deliver and consume the message. The NameServer is usually deployed in a cluster mode, and each instance does not communicate with each other. Broker registers its own routing information with each NameServer, so each NameServer instance stores a complete routing information. When a NameServer is offline for some reason, the Broker can still synchronize its routing information with other NameServers. The Producer and Consumer can still dynamically sense the information of the Broker’s routing.</p>
</li>
<li><p>BrokerServer：Broker is responsible for the storage, delivery and query of messages and high availability guarantees. In order to achieve these functions, Broker includes the following important sub-modules.</p>
</li>
</ul>
<ol>
<li>Remoting Module：The entire broker entity handles requests from the clients side.</li>
<li>Client Manager：Topic subscription information for managing the client (Producer&#x2F;Consumer) and maintaining the Consumer</li>
<li>Store Service：Provides a convenient and simple API interface for handling message storage to physical hard disks and query functions.</li>
<li>HA Service：Highly available service that provides data synchronization between Master Broker and Slave Broker.</li>
<li>Index Service：The message delivered to the Broker is indexed according to a specific Message key to provide a quick query of the message.</li>
</ol>
<p><img src="/image/rocketmq_architecture_2.png"></p>
<h2 id="Deployment-architecture"><a href="#Deployment-architecture" class="headerlink" title="Deployment architecture"></a>Deployment architecture</h2><p><img src="/image/rocketmq_architecture_3.png"></p>
<h3 id="RocketMQ-Network-deployment-features"><a href="#RocketMQ-Network-deployment-features" class="headerlink" title="RocketMQ Network deployment features"></a>RocketMQ Network deployment features</h3><ul>
<li><p>NameServer is an almost stateless node that can be deployed in a cluster without any information synchronization between nodes.</p>
</li>
<li><p>The broker deployment is relatively complex. The Broker is divided into the Master and the Slave. One Master can correspond to multiple Slaves. However, one Slave can only correspond to one Master. The correspondence between the Master and the Slave is defined by specifying the same BrokerName and different BrokerId. The BrokerId is 0. Indicates Master, non-zero means Slave. The Master can also deploy multiple. Each broker establishes a long connection with all nodes in the NameServer cluster, and periodically registers Topic information to all NameServers. Note: The current RocketMQ version supports a Master Multi Slave on the deployment architecture, but only the slave server with BrokerId&#x3D;1 will participate in the read load of the message.</p>
</li>
<li><p>The Producer establishes a long connection with one of the nodes in the NameServer cluster (randomly selected), periodically obtains Topic routing information from the NameServer, and establishes a long connection to the Master that provides the Topic service, and periodically sends a heartbeat to the Master. Producer is completely stateless and can be deployed in a cluster.</p>
</li>
<li><p>The Consumer establishes a long connection with one of the nodes in the NameServer cluster (randomly selected), periodically obtains Topic routing information from the NameServer, and establishes a long connection to the Master and Slave that provides the Topic service, and periodically sends heartbeats to the Master and Slave. The Consumer can subscribe to the message from the Master or subscribe to the message from the Slave. When the consumer pulls the message to the Master, the Master server will generate a read according to the distance between the offset and the maximum offset. I&#x2F;O), and whether the server is readable or not, the next time it is recommended to pull from the Master or Slave.</p>
</li>
</ul>
<p>Describe the cluster workflow in conjunction with the deployment architecture diagram:</p>
<ul>
<li>Start the NameServer, listen to the port after the NameServer, and wait for the Broker, Producer, and Consumer to connect, which is equivalent to a routing control center.</li>
<li>The Broker starts, keeps a long connection with all NameServers, and sends heartbeat packets periodically. The heartbeat packet contains the current broker information (IP+ port, etc.) and stores all Topic information. After the registration is successful, there is a mapping relationship between Topic and Broker in the NameServer cluster.</li>
<li>Before sending and receiving a message, create a Topic. When creating a Topic, you need to specify which Brokers the Topic should be stored on, or you can automatically create a Topic when sending a message.</li>
<li>Producer sends a message. When starting, it first establishes a long connection with one of the NameServer clusters, and obtains from the NameServer which Brokers are currently sent by the Topic. Polling selects a queue from the queue list and then establishes with the broker where the queue is located. Long connection to send a message to the broker.</li>
<li>The Consumer is similar to the Producer. It establishes a long connection with one of the NameServers, obtains which Brokers the current Topic exists on, and then directly establishes a connection channel with the Broker to start consuming messages.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/en/best_practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/en/best_practice/" class="post-title-link" itemprop="url">RocketMQ Best practices</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:58:45" itemprop="dateModified" datetime="2025-04-26T20:58:45+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Best-practices"><a href="#Best-practices" class="headerlink" title="Best practices"></a>Best practices</h1><h2 id="1-Producer"><a href="#1-Producer" class="headerlink" title="1 Producer"></a>1 Producer</h2><h2 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h2><h2 id="3-Broker"><a href="#3-Broker" class="headerlink" title="3 Broker"></a>3 Broker</h2><h3 id="3-1-Broker-Role"><a href="#3-1-Broker-Role" class="headerlink" title="3.1 Broker Role"></a>3.1 Broker Role</h3><h3 id="3-2-FlushDiskType"><a href="#3-2-FlushDiskType" class="headerlink" title="3.2 FlushDiskType"></a>3.2 FlushDiskType</h3><h3 id="3-3-Broker-Configuration"><a href="#3-3-Broker-Configuration" class="headerlink" title="3.3 Broker Configuration"></a>3.3 Broker Configuration</h3><table>
<thead>
<tr>
<th>Parameter name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>listenPort</td>
<td>10911</td>
<td>listen port for client</td>
</tr>
<tr>
<td>namesrvAddr</td>
<td>null</td>
<td>name server address</td>
</tr>
<tr>
<td>brokerIP1</td>
<td>InetAddress for network interface</td>
<td>Should be configured if having multiple addresses</td>
</tr>
<tr>
<td>brokerIP2</td>
<td>InetAddress for network interface</td>
<td>If configured for the Master broker in the Master&#x2F;Slave cluster, slave broker will connect to this port for data synchronization</td>
</tr>
<tr>
<td>brokerName</td>
<td>null</td>
<td>broker name</td>
</tr>
<tr>
<td>brokerClusterName</td>
<td>DefaultCluster</td>
<td>this broker belongs to which cluster</td>
</tr>
<tr>
<td>brokerId</td>
<td>0</td>
<td>broker id, 0 means master, positive integers mean slave</td>
</tr>
<tr>
<td>storePathCommitLog</td>
<td>$HOME&#x2F;store&#x2F;commitlog&#x2F;</td>
<td>file path for commit log</td>
</tr>
<tr>
<td>storePathConsumerQueue</td>
<td>$HOME&#x2F;store&#x2F;consumequeue&#x2F;</td>
<td>file path for consume queue</td>
</tr>
<tr>
<td>mappedFileSizeCommitLog</td>
<td>1024 * 1024 * 1024(1G)</td>
<td>mapped file size for commit log</td>
</tr>
<tr>
<td>deleteWhen</td>
<td>04</td>
<td>When to delete the commitlog which is out of the reserve time</td>
</tr>
<tr>
<td>fileReserverdTime</td>
<td>72</td>
<td>The number of hours to keep a commitlog before deleting it</td>
</tr>
<tr>
<td>brokerRole</td>
<td>ASYNC_MASTER</td>
<td>SYNC_MASTER&#x2F;ASYNC_MASTER&#x2F;SLAVE</td>
</tr>
<tr>
<td>flushDiskType</td>
<td>ASYNC_FLUSH</td>
<td>{SYNC_FLUSH&#x2F;ASYNC_FLUSH}. Broker of SYNC_FLUSH mode flushes each message onto disk before acknowledging producer. Broker of ASYNC_FLUSH mode, on the other hand, takes advantage of group-committing, achieving better performance.</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/en/design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/en/design/" class="post-title-link" itemprop="url">RocketMQ Design</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 21:00:28" itemprop="dateModified" datetime="2025-04-26T21:00:28+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><h3 id="1-Message-Store"><a href="#1-Message-Store" class="headerlink" title="1 Message Store"></a>1 Message Store</h3><p><img src="/../cn/image/rocketmq_design_1.png"></p>
<h4 id="1-1-The-Architecure-of-Message-Store"><a href="#1-1-The-Architecure-of-Message-Store" class="headerlink" title="1.1 The Architecure of Message Store"></a>1.1 The Architecure of Message Store</h4><h4 id="1-2-PageCache-and-Memory-Map-Mmap"><a href="#1-2-PageCache-and-Memory-Map-Mmap" class="headerlink" title="1.2 PageCache and Memory-Map(Mmap)"></a>1.2 PageCache and Memory-Map(Mmap)</h4><h4 id="1-3-Message-Flush"><a href="#1-3-Message-Flush" class="headerlink" title="1.3 Message Flush"></a>1.3 Message Flush</h4><p><img src="/../cn/image/rocketmq_design_2.png"></p>
<h3 id="2-Communication-Mechanism"><a href="#2-Communication-Mechanism" class="headerlink" title="2 Communication Mechanism"></a>2 Communication Mechanism</h3><h4 id="2-1-The-class-diagram-of-Remoting-module"><a href="#2-1-The-class-diagram-of-Remoting-module" class="headerlink" title="2.1 The class diagram of Remoting module"></a>2.1 The class diagram of Remoting module</h4><p><img src="/../cn/image/rocketmq_design_3.png"></p>
<h4 id="2-2-The-design-of-protocol-and-encode-x2F-decode"><a href="#2-2-The-design-of-protocol-and-encode-x2F-decode" class="headerlink" title="2.2 The design of protocol and encode&#x2F;decode"></a>2.2 The design of protocol and encode&#x2F;decode</h4><p><img src="/../cn/image/rocketmq_design_4.png"></p>
<h4 id="2-3-The-three-ways-and-process-of-message-communication"><a href="#2-3-The-three-ways-and-process-of-message-communication" class="headerlink" title="2.3 The three ways and process of message communication"></a>2.3 The three ways and process of message communication</h4><p><img src="/../cn/image/rocketmq_design_5.png"></p>
<h4 id="2-4-The-multi-thread-design-of-Reactor"><a href="#2-4-The-multi-thread-design-of-Reactor" class="headerlink" title="2.4 The multi-thread design of Reactor"></a>2.4 The multi-thread design of Reactor</h4><p><img src="/../cn/image/rocketmq_design_6.png"></p>
<h3 id="3-Message-Filter"><a href="#3-Message-Filter" class="headerlink" title="3 Message Filter"></a>3 Message Filter</h3><p><img src="/../cn/image/rocketmq_design_7.png"></p>
<h3 id="4-LoadBalancing"><a href="#4-LoadBalancing" class="headerlink" title="4 LoadBalancing"></a>4 LoadBalancing</h3><h4 id="4-1-The-loadBalance-of-Producer"><a href="#4-1-The-loadBalance-of-Producer" class="headerlink" title="4.1 The loadBalance of Producer"></a>4.1 The loadBalance of Producer</h4><h4 id="4-2-The-loadBalance-of-Consumer"><a href="#4-2-The-loadBalance-of-Consumer" class="headerlink" title="4.2 The loadBalance of Consumer"></a>4.2 The loadBalance of Consumer</h4><p><img src="/../cn/image/rocketmq_design_8.png"></p>
<p><img src="/../cn/image/rocketmq_design_9.png"></p>
<h3 id="5-Transactional-Message"><a href="#5-Transactional-Message" class="headerlink" title="5 Transactional Message"></a>5 Transactional Message</h3><p>Apache RocketMQ supports distributed transactional message from version 4.3.0. RocketMQ implements transactional message by using the protocol of 2PC(two-phase commit), in addition adding a compensation logic to handle timeout-case or failure-case of commit-phase, as shown below.</p>
<p><img src="/../cn/image/rocketmq_design_10.png"></p>
<h4 id="5-1-The-Process-of-RocketMQ-Transactional-Message"><a href="#5-1-The-Process-of-RocketMQ-Transactional-Message" class="headerlink" title="5.1 The Process of RocketMQ Transactional Message"></a>5.1 The Process of RocketMQ Transactional Message</h4><p>The picture above shows the overall architecture of transactional message, including the sending of message(commit-request phase), the sending of commit&#x2F;rollback(commit phase) and the compensation process.</p>
<ol>
<li><p>The sending of message and Commit&#x2F;Rollback.<br> (1) Sending the message(named Half message in RocketMQ)<br> (2) The server responds the writing result(success or failure) of Half message.<br> (3) Handle local transaction according to the result(local transaction won’t be executed when the result is failure).<br> (4) Sending Commit&#x2F;Rollback to broker according to the result of local transaction(Commit will generate message index and make the message visible to consumers).</p>
</li>
<li><p>Compensation process<br> (1) For a transactional message without a Commit&#x2F;Rollback (means the message in the pending status), a “back-check” request is initiated from the broker.<br> (2) The Producer receives the “back-check” request and checks the status of the local transaction corresponding to the “back-check” message.<br> (3) Redo Commit or Rollback based on local transaction status.<br> The compensation phase is used to resolve the timeout or failure case of the message Commit or Rollback.</p>
</li>
</ol>
<h4 id="5-2-The-design-of-RocketMQ-Transactional-Message"><a href="#5-2-The-design-of-RocketMQ-Transactional-Message" class="headerlink" title="5.2 The design of RocketMQ Transactional Message"></a>5.2 The design of RocketMQ Transactional Message</h4><ol>
<li>Transactional message is invisible to users in first phase(commit-request phase)</li>
</ol>
<p>  Upon on the main process of transactional message, the message of first phase is invisible to the user. This is also the biggest difference from normal message. So how do we write the message while making it invisible to the user? And below is the solution of RocketMQ: if the message is a Half message, the topic and queueId of the original message will be backed up, and then changes the topic to RMQ_SYS_TRANS_HALF_TOPIC. Since the consumer group does not subscribe to the topic, the consumer cannot consume the Half message. Then RocketMQ starts a timing task, pulls the message for RMQ_SYS_TRANS_HALF_TOPIC, obtains a channel according to producer group and sends a back-check to query local transaction status, and decide whether to submit or roll back the message according to the status.  </p>
<p>  In RocketMQ, the storage structure of the message in the broker is as follows. Each message has corresponding index information. The Consumer reads the content of the message through the secondary index of the ConsumeQueue. The flow is as follows:</p>
<p><img src="/../cn/image/rocketmq_design_11.png"></p>
<p>  The specific implementation strategy of RocketMQ is: if the transactional message is written, topic and queueId of the message are replaced, and the original topic and queueId are stored in the properties of the message. Because the replace of the topic, the message will not be forwarded to the Consumer Queue of the original topic, and the consumer cannot perceive the existence of the message and will not consume it. In fact, changing the topic is the conventional method of RocketMQ(just recall the implementation mechanism of the delay message).</p>
<ol start="2">
<li>Commit&#x2F;Rollback operation and introduction of Op message</li>
</ol>
<p>  After finishing writing a message that is invisible to the user in the first phase, here comes two cases in the second phase. One is Commit operation, after which the message needs to be visible to the user; the other one is Rollback operation, after which the first phase message(Half message) needs to be revoked. For the case of Rollback, since first-phase message itself is invisible to the user, there is no need to actually revoke the message (in fact, RocketMQ can’t actually delete a message because it is a sequential-write file). But still some operation needs to be done to identity the final status of the message, to differ it from pending status message. To do this, the concept of “Op message” is introduced, which means the message has a certain status(Commit or Rollback). If a transactional message does not have a corresponding Op message, the status of the transaction is still undetermined (probably the second-phase failed). By introducing the Op message, the RocketMQ records an Op message for every Half message regardless it is Commit or Rollback. The only difference between Commit and Rollback is that when it comes to Commit, the index of the Half message is created before the Op message is written.</p>
<ol start="3">
<li>How Op message stored and the correspondence between Op message and Half message</li>
</ol>
<p>  RocketMQ writes the Op message to a specific system topic(RMQ_SYS_TRANS_OP_HALF_TOPIC) which will be created via the method - TransactionalMessageUtil.buildOpTopic(); this topic is an internal Topic (like the topic of RMQ_SYS_TRANS_HALF_TOPIC) and will not be consumed by the user. The content of the Op message is the physical offset of the corresponding Half message. Through the Op message we can index to the Half message for subsequent check-back operation.</p>
<p><img src="/../cn/image/rocketmq_design_12.png"></p>
<ol start="4">
<li>Index construction of Half messages</li>
</ol>
<p>  When performing Commit operation of the second phase, the index of the Half message needs to be built. Since the Half message is written to a special topic(RMQ_SYS_TRANS_HALF_TOPIC) in the first phase of 2PC, so it needs to be read out from the special topic when building index, and replace the topic and queueId with the real target topic and queueId, and then write through a normal message that is visible to the user. Therefore, in conclusion, the second phase recovers a complete normal message using the content of the Half message stored in the first phase, and then goes through the message-writing process.</p>
<ol start="5">
<li>How to handle the message failed in the second phase？</li>
</ol>
<p>  If commit&#x2F;rollback phase fails, for example, a network problem causes the Commit to fail when you do Commit. Then certain strategy is required to make sure the message finally commit. RocketMQ uses a compensation mechanism called “back-check”. The broker initiates a back-check request for the message in pending status, and sends the request to the corresponding producer side (the same producer group as the producer group who sent the Half message). The producer checks the status of local transaction and redo Commit or Rollback. The broker performs the back-check by comparing the RMQ_SYS_TRANS_HALF_TOPIC messages and the RMQ_SYS_TRANS_OP_HALF_TOPIC messages and advances the checkpoint(recording those transactional messages that the status are certain).</p>
<p>  RocketMQ does not back-check the status of transactional messages endlessly. The default time is 15. If the transaction status is still unknown after 15 times, RocketMQ will roll back the message by default.</p>
<h3 id="6-Message-Query"><a href="#6-Message-Query" class="headerlink" title="6 Message Query"></a>6 Message Query</h3><h4 id="6-1-Query-messages-by-messageId"><a href="#6-1-Query-messages-by-messageId" class="headerlink" title="6.1 Query messages by messageId"></a>6.1 Query messages by messageId</h4><h4 id="6-2-Query-messages-by-message-key"><a href="#6-2-Query-messages-by-message-key" class="headerlink" title="6.2 Query messages by message key"></a>6.2 Query messages by message key</h4><p><img src="/../cn/image/rocketmq_design_13.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/cn/dledger/deploy_guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/cn/dledger/deploy_guide/" class="post-title-link" itemprop="url">RocketMQ Dledger集群搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:56:56" itemprop="dateModified" datetime="2025-04-26T20:56:56+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dledger集群搭建"><a href="#Dledger集群搭建" class="headerlink" title="Dledger集群搭建"></a>Dledger集群搭建</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文档主要介绍如何部署自动容灾切换的 RocketMQ-on-DLedger Group。</p>
<p>RocketMQ-on-DLedger Group 是指一组<strong>相同名称</strong>的 Broker，至少需要 3 个节点，通过 Raft 自动选举出一个 Leader，其余节点 作为 Follower，并在 Leader 和 Follower 之间复制数据以保证高可用。<br>RocketMQ-on-DLedger Group 能自动容灾切换，并保证数据一致。<br>RocketMQ-on-DLedger Group 是可以水平扩展的，也即可以部署任意多个 RocketMQ-on-DLedger Group 同时对外提供服务。  </p>
<h2 id="1-新集群部署"><a href="#1-新集群部署" class="headerlink" title="1. 新集群部署"></a>1. 新集群部署</h2><h4 id="1-1-编写配置"><a href="#1-1-编写配置" class="headerlink" title="1.1 编写配置"></a>1.1 编写配置</h4><p>每个 RocketMQ-on-DLedger Group 至少准备三台机器（本文假设为 3）。<br>编写 3 个配置文件，建议参考 conf&#x2F;dledger 目录下的配置文件样例。<br>关键配置介绍：  </p>
<table>
<thead>
<tr>
<th>name</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>enableDLegerCommitLog</td>
<td>是否启动 DLedger</td>
<td>true</td>
</tr>
<tr>
<td>dLegerGroup</td>
<td>DLedger Raft Group的名字，建议和 brokerName 保持一致</td>
<td>RaftNode00</td>
</tr>
<tr>
<td>dLegerPeers</td>
<td>DLedger Group 内各节点的端口信息，同一个 Group 内的各个节点配置必须要保证一致</td>
<td>n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</td>
</tr>
<tr>
<td>dLegerSelfId</td>
<td>节点 id, 必须属于 dLegerPeers 中的一个；同 Group 内各个节点要唯一</td>
<td>n0</td>
</tr>
<tr>
<td>sendMessageThreadPoolNums</td>
<td>发送线程个数，建议配置成 Cpu 核数</td>
<td>16</td>
</tr>
</tbody></table>
<p>这里贴出 conf&#x2F;dledger&#x2F;broker-n0.conf 的配置举例。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName = RaftCluster</span><br><span class="line">brokerName=RaftNode00</span><br><span class="line">listenPort=30911</span><br><span class="line">namesrvAddr=127.0.0.1:9876</span><br><span class="line">storePathRootDir=/tmp/rmqstore/node00</span><br><span class="line">storePathCommitLog=/tmp/rmqstore/node00/commitlog</span><br><span class="line">enableDLegerCommitLog=true</span><br><span class="line">dLegerGroup=RaftNode00</span><br><span class="line">dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</span><br><span class="line">## must be unique</span><br><span class="line">dLegerSelfId=n0</span><br><span class="line">sendMessageThreadPoolNums=16</span><br></pre></td></tr></table></figure>

<h3 id="1-2-启动-Broker"><a href="#1-2-启动-Broker" class="headerlink" title="1.2 启动 Broker"></a>1.2 启动 Broker</h3><p>与老版本的启动方式一致。</p>
<p><code>nohup sh bin/mqbroker -c conf/dledger/xxx-n0.conf &amp; </code><br><code>nohup sh bin/mqbroker -c conf/dledger/xxx-n1.conf &amp; </code><br><code>nohup sh bin/mqbroker -c conf/dledger/xxx-n2.conf &amp; </code>  </p>
<h2 id="2-旧集群升级"><a href="#2-旧集群升级" class="headerlink" title="2. 旧集群升级"></a>2. 旧集群升级</h2><p>如果旧集群采用 Master 方式部署，则每个 Master 都需要转换成一个 RocketMQ-on-DLedger Group。<br>如果旧集群采用 Master-Slave 方式部署，则每个 Master-Slave 组都需要转换成一个 RocketMQ-on-DLedger Group。</p>
<h3 id="2-1-杀掉旧的-Broker"><a href="#2-1-杀掉旧的-Broker" class="headerlink" title="2.1 杀掉旧的 Broker"></a>2.1 杀掉旧的 Broker</h3><p>可以通过 kill 命令来完成，也可以调用 <code>bin/mqshutdown broker</code>。</p>
<h3 id="2-2-检查旧的-Commitlog"><a href="#2-2-检查旧的-Commitlog" class="headerlink" title="2.2 检查旧的 Commitlog"></a>2.2 检查旧的 Commitlog</h3><p>RocketMQ-on-DLedger 组中的每个节点，可以兼容旧的 Commitlog ，但其 Raft 复制过程，只能针对新增加的消息。因此，为了避免出现异常，需要保证 旧的 Commitlog 是一致的。<br>如果旧的集群是采用 Master-Slave 方式部署，有可能在shutdown时，其数据并不是一致的，建议通过md5sum 的方式，检查最近的最少 2 个 Commmitlog 文件，如果发现不一致，则通过拷贝的方式进行对齐。  </p>
<p>虽然 RocketMQ-on-DLedger Group 也可以以 2 节点方式部署，但其会丧失容灾切换能力（2n + 1 原则，至少需要3个节点才能容忍其中 1 个宕机）。<br>所以在对齐了 Master 和 Slave 的 Commitlog 之后，还需要准备第 3 台机器，并把旧的 Commitlog 从 Master 拷贝到 第 3 台机器（记得同时拷贝一下 config 文件夹）。  </p>
<p>在 3 台机器准备好了之后，旧 Commitlog 文件也保证一致之后，就可以开始走下一步修改配置了。</p>
<h3 id="2-3-修改配置"><a href="#2-3-修改配置" class="headerlink" title="2.3 修改配置"></a>2.3 修改配置</h3><p>参考新集群部署。</p>
<h3 id="2-4-重新启动-Broker"><a href="#2-4-重新启动-Broker" class="headerlink" title="2.4 重新启动 Broker"></a>2.4 重新启动 Broker</h3><p>参考新集群部署。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/cn/dledger/quick_start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/cn/dledger/quick_start/" class="post-title-link" itemprop="url">RocketMQ Dledger快速搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:56:51" itemprop="dateModified" datetime="2025-04-26T20:56:51+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Dledger快速搭建"><a href="#Dledger快速搭建" class="headerlink" title="Dledger快速搭建"></a>Dledger快速搭建</h1><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该文档主要介绍如何快速构建和部署基于 DLedger 的可以自动容灾切换的 RocketMQ 集群。</p>
<p>详细的新集群部署和旧集群升级指南请参考 <a href="deploy_guide.md">部署指南</a>。</p>
<h3 id="1-源码构建"><a href="#1-源码构建" class="headerlink" title="1. 源码构建"></a>1. 源码构建</h3><p>构建分为两个部分，需要先构建 DLedger，然后 构建 RocketMQ</p>
<h4 id="1-1-构建-DLedger"><a href="#1-1-构建-DLedger" class="headerlink" title="1.1 构建 DLedger"></a>1.1 构建 DLedger</h4><p><code>git clone https://github.com/openmessaging/openmessaging-storage-dledger.git</code></p>
<p><code>cd openmessaging-storage-dledger</code></p>
<p><code>mvn clean install -DskipTests</code></p>
<h4 id="1-2-构建-RocketMQ"><a href="#1-2-构建-RocketMQ" class="headerlink" title="1.2 构建 RocketMQ"></a>1.2 构建 RocketMQ</h4><p><code>git clone https://github.com/apache/rocketmq.git</code></p>
<p><code>cd rocketmq</code></p>
<p><code>git checkout -b store_with_dledger origin/store_with_dledger</code></p>
<p><code>mvn -Prelease-all -DskipTests clean install -U</code></p>
<h3 id="2-快速部署"><a href="#2-快速部署" class="headerlink" title="2. 快速部署"></a>2. 快速部署</h3><p>在构建成功后</p>
<p><code>cd distribution/target/apache-rocketmq</code></p>
<p><code>sh bin/dledger/fast-try.sh start</code></p>
<p>如果上面的步骤执行成功，可以通过 mqadmin 运维命令查看集群状态。</p>
<p><code>sh bin/mqadmin clusterList -n 127.0.0.1:9876</code></p>
<p>顺利的话，会看到如下内容：</p>
<p><img src="https://img.alicdn.com/5476e8b07b923/TB11Z.ZyCzqK1RjSZFLXXcn2XXa" alt="ClusterList"></p>
<p>（BID 为 0 的表示 Master，其余都是 Follower）</p>
<p>启动成功，现在可以向集群收发消息，并进行容灾切换测试了。</p>
<p>关闭快速集群，可以执行：</p>
<p><code>sh bin/dledger/fast-try.sh stop</code></p>
<p>快速部署，默认配置在 conf&#x2F;dledger 里面，默认的存储路径在 &#x2F;tmp&#x2F;rmqstore。</p>
<h3 id="3-容灾切换"><a href="#3-容灾切换" class="headerlink" title="3. 容灾切换"></a>3. 容灾切换</h3><p>部署成功，杀掉 Leader 之后（在上面的例子中，杀掉端口 30931 所在的进程），等待约 10s 左右，用 clusterList 命令查看集群，就会发现 Leader 切换到另一个节点了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/cn/acl/user_guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/cn/acl/user_guide/" class="post-title-link" itemprop="url">RocketMQ 权限控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:57:13" itemprop="dateModified" datetime="2025-04-26T20:57:13+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><hr>
<h2 id="1-权限控制特性介绍"><a href="#1-权限控制特性介绍" class="headerlink" title="1.权限控制特性介绍"></a>1.权限控制特性介绍</h2><p>权限控制（ACL）主要为RocketMQ提供Topic资源级别的用户访问控制。用户在使用RocketMQ权限控制时，可以在Client客户端通过 RPCHook注入AccessKey和SecretKey签名；同时，将对应的权限控制属性（包括Topic访问权限、IP白名单和AccessKey和SecretKey签名等）设置在distribution&#x2F;conf&#x2F;plain_acl.yml的配置文件中。Broker端对AccessKey所拥有的权限进行校验，校验不过，抛出异常；<br>ACL客户端可以参考：<strong>org.apache.rocketmq.example.simple</strong>包下面的<strong>AclClient</strong>代码。</p>
<h2 id="2-权限控制的定义与属性值"><a href="#2-权限控制的定义与属性值" class="headerlink" title="2. 权限控制的定义与属性值"></a>2. 权限控制的定义与属性值</h2><h3 id="2-1权限定义"><a href="#2-1权限定义" class="headerlink" title="2.1权限定义"></a>2.1权限定义</h3><p>对RocketMQ的Topic资源访问权限控制定义主要如下表所示，分为以下四种</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DENY</td>
<td>拒绝</td>
</tr>
<tr>
<td>ANY</td>
<td>PUB 或者 SUB 权限</td>
</tr>
<tr>
<td>PUB</td>
<td>发送权限</td>
</tr>
<tr>
<td>SUB</td>
<td>订阅权限</td>
</tr>
</tbody></table>
<h3 id="2-2-权限定义的关键属性"><a href="#2-2-权限定义的关键属性" class="headerlink" title="2.2 权限定义的关键属性"></a>2.2 权限定义的关键属性</h3><table>
<thead>
<tr>
<th>字段</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>globalWhiteRemoteAddresses</td>
<td>*;192.168.*.*;192.168.0.1</td>
<td>全局IP白名单</td>
</tr>
<tr>
<td>accessKey</td>
<td>字符串</td>
<td>Access Key</td>
</tr>
<tr>
<td>secretKey</td>
<td>字符串</td>
<td>Secret Key</td>
</tr>
<tr>
<td>whiteRemoteAddress</td>
<td>*;192.168.*.*;192.168.0.1</td>
<td>用户IP白名单</td>
</tr>
<tr>
<td>admin</td>
<td>true;false</td>
<td>是否管理员账户</td>
</tr>
<tr>
<td>defaultTopicPerm</td>
<td>DENY;PUB;SUB;PUB|SUB</td>
<td>默认的Topic权限</td>
</tr>
<tr>
<td>defaultGroupPerm</td>
<td>DENY;PUB;SUB;PUB|SUB</td>
<td>默认的ConsumerGroup权限</td>
</tr>
<tr>
<td>topicPerms</td>
<td>topic&#x3D;权限</td>
<td>各个Topic的权限</td>
</tr>
<tr>
<td>groupPerms</td>
<td>group&#x3D;权限</td>
<td>各个ConsumerGroup的权限</td>
</tr>
</tbody></table>
<p>具体可以参考<strong>distribution&#x2F;conf&#x2F;plain_acl.yml</strong>配置文件</p>
<h2 id="3-支持权限控制的集群部署"><a href="#3-支持权限控制的集群部署" class="headerlink" title="3. 支持权限控制的集群部署"></a>3. 支持权限控制的集群部署</h2><p>在<strong>distribution&#x2F;conf&#x2F;plain_acl.yml</strong>配置文件中按照上述说明定义好权限属性后，打开<strong>aclEnable</strong>开关变量即可开启RocketMQ集群的ACL特性。这里贴出Broker端开启ACL特性的properties配置文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">storePathRootDir=/data/rocketmq/rootdir-a-m</span><br><span class="line">storePathCommitLog=/data/rocketmq/commitlog-a-m</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">## if acl is open,the flag will be true</span><br><span class="line">aclEnable=true</span><br><span class="line">listenPort=10911</span><br><span class="line">brokerIP1=XX.XX.XX.XX1</span><br><span class="line">namesrvAddr=XX.XX.XX.XX:9876</span><br></pre></td></tr></table></figure>

<h2 id="4-权限控制主要流程"><a href="#4-权限控制主要流程" class="headerlink" title="4. 权限控制主要流程"></a>4. 权限控制主要流程</h2><p>ACL主要流程分为两部分，主要包括权限解析和权限校验。</p>
<h3 id="4-1-权限解析"><a href="#4-1-权限解析" class="headerlink" title="4.1 权限解析"></a>4.1 权限解析</h3><p>Broker端对客户端的RequestCommand请求进行解析，拿到需要鉴权的属性字段。<br>主要包括：<br>（1）AccessKey：类似于用户名，代指用户主体，权限数据与之对应；<br>（2）Signature：客户根据 SecretKey 签名得到的串，服务端再用SecretKey进行签名验证；</p>
<h3 id="4-2-权限校验"><a href="#4-2-权限校验" class="headerlink" title="4.2 权限校验"></a>4.2 权限校验</h3><p>Broker端对权限的校验逻辑主要分为以下几步：<br>（1）检查是否命中全局 IP 白名单；如果是，则认为校验通过；否则走 2；<br>（2）检查是否命中用户 IP 白名单；如果是，则认为校验通过；否则走 3；<br>（3）校验签名，校验不通过，抛出异常；校验通过，则走 4；<br>（4）对用户请求所需的权限 和 用户所拥有的权限进行校验；不通过，抛出异常；<br>用户所需权限的校验需要注意已下内容：<br>（1）特殊的请求例如 UPDATE_AND_CREATE_TOPIC 等，只能由 admin 账户进行操作；<br>（2）对于某个资源，如果有显性配置权限，则采用配置的权限；如果没有显性配置权限，则采用默认的权限；</p>
<h2 id="5-热加载修改后权限控制定义"><a href="#5-热加载修改后权限控制定义" class="headerlink" title="5. 热加载修改后权限控制定义"></a>5. 热加载修改后权限控制定义</h2><p>RocketMQ的权限控制存储的默认实现是基于yml配置文件。用户可以动态修改权限控制定义的属性，而不需重新启动Broker服务节点。</p>
<h2 id="6-权限控制的使用限制"><a href="#6-权限控制的使用限制" class="headerlink" title="6. 权限控制的使用限制"></a>6. 权限控制的使用限制</h2><p>(1)如果ACL与高可用部署(Master&#x2F;Slave架构)同时启用，那么需要在Broker Master节点的distribution&#x2F;conf&#x2F;plain_acl.yml配置文件中<br>设置全局白名单信息，即为将Slave节点的ip地址设置至Master节点plain_acl.yml配置文件的全局白名单中。</p>
<p>(2)如果ACL与高可用部署(多副本Dledger架构)同时启用，由于出现节点宕机时，Dledger Group组内会自动选主，那么就需要将Dledger Group组<br>内所有Broker节点的plain_acl.yml配置文件的白名单设置所有Broker节点的ip地址。</p>
<h2 id="7-ACL-mqadmin配置管理命令"><a href="#7-ACL-mqadmin配置管理命令" class="headerlink" title="7. ACL mqadmin配置管理命令"></a>7. ACL mqadmin配置管理命令</h2><h3 id="7-1-更新ACL配置文件中“account”的属性值"><a href="#7-1-更新ACL配置文件中“account”的属性值" class="headerlink" title="7.1 更新ACL配置文件中“account”的属性值"></a>7.1 更新ACL配置文件中“account”的属性值</h3><p>该命令的示例如下：</p>
<p>sh mqadmin updateAclConfig -n 192.168.1.2:9876 -b 192.168.12.134:10911 -a RocketMQ -s 1234567809123<br>-t topicA&#x3D;DENY,topicD&#x3D;SUB -g groupD&#x3D;DENY,groupB&#x3D;SUB</p>
<p>说明：如果不存在则会在ACL Config YAML配置文件中创建；若存在，则会更新对应的“accounts”的属性值;<br>如果指定的是集群名称，则会在集群中各个broker节点执行该命令；否则会在单个broker节点执行该命令。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>eg:192.168.1.2:9876</td>
<td>namesrv地址(必填)</td>
</tr>
<tr>
<td>c</td>
<td>eg:DefaultCluster</td>
<td>指定集群名称(与broker地址二选一)</td>
</tr>
<tr>
<td>b</td>
<td>eg:192.168.12.134:10911</td>
<td>指定broker地址(与集群名称二选一)</td>
</tr>
<tr>
<td>a</td>
<td>eg:RocketMQ</td>
<td>Access Key值(必填)</td>
</tr>
<tr>
<td>s</td>
<td>eg:1234567809123</td>
<td>Secret Key值(可选)</td>
</tr>
<tr>
<td>m</td>
<td>eg:true</td>
<td>是否管理员账户(可选)</td>
</tr>
<tr>
<td>w</td>
<td>eg:192.168.0.*</td>
<td>whiteRemoteAddress,用户IP白名单(可选)</td>
</tr>
<tr>
<td>i</td>
<td>eg:DENY;PUB;SUB;PUB|SUB</td>
<td>defaultTopicPerm,默认Topic权限(可选)</td>
</tr>
<tr>
<td>u</td>
<td>eg:DENY;PUB;SUB;PUB|SUB</td>
<td>defaultGroupPerm,默认ConsumerGroup权限(可选)</td>
</tr>
<tr>
<td>t</td>
<td>eg:topicA&#x3D;DENY,topicD&#x3D;SUB</td>
<td>topicPerms,各个Topic的权限(可选)</td>
</tr>
<tr>
<td>g</td>
<td>eg:groupD&#x3D;DENY,groupB&#x3D;SUB</td>
<td>groupPerms,各个ConsumerGroup的权限(可选)</td>
</tr>
</tbody></table>
<h3 id="7-2-删除ACL配置文件里面的对应“account”"><a href="#7-2-删除ACL配置文件里面的对应“account”" class="headerlink" title="7.2 删除ACL配置文件里面的对应“account”"></a>7.2 删除ACL配置文件里面的对应“account”</h3><p>该命令的示例如下：</p>
<p>sh mqadmin deleteAccessConfig -n 192.168.1.2:9876 -c DefaultCluster -a RocketMQ</p>
<p>说明：如果指定的是集群名称，则会在集群中各个broker节点执行该命令；否则会在单个broker节点执行该命令。<br>其中，参数”a”为Access Key的值，用以标识唯一账户id，因此该命令的参数中指定账户id即可。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>eg:192.168.1.2:9876</td>
<td>namesrv地址(必填)</td>
</tr>
<tr>
<td>c</td>
<td>eg:DefaultCluster</td>
<td>指定集群名称(与broker地址二选一)</td>
</tr>
<tr>
<td>b</td>
<td>eg:192.168.12.134:10911</td>
<td>指定broker地址(与集群名称二选一)</td>
</tr>
<tr>
<td>a</td>
<td>eg:RocketMQ</td>
<td>Access Key的值(必填)</td>
</tr>
</tbody></table>
<h3 id="7-3-更新ACL配置文件里面中的全局白名单"><a href="#7-3-更新ACL配置文件里面中的全局白名单" class="headerlink" title="7.3 更新ACL配置文件里面中的全局白名单"></a>7.3 更新ACL配置文件里面中的全局白名单</h3><p>该命令的示例如下：</p>
<p>sh mqadmin updateGlobalWhiteAddr -n 192.168.1.2:9876 -b 192.168.12.134:10911 -g 10.10.154.1,10.10.154.2</p>
<p>说明：如果指定的是集群名称，则会在集群中各个broker节点执行该命令；否则会在单个broker节点执行该命令。<br>其中，参数”g”为全局IP白名的值，用以更新ACL配置文件中的“globalWhiteRemoteAddresses”字段的属性值。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>eg:192.168.1.2:9876</td>
<td>namesrv地址(必填)</td>
</tr>
<tr>
<td>c</td>
<td>eg:DefaultCluster</td>
<td>指定集群名称(与broker地址二选一)</td>
</tr>
<tr>
<td>b</td>
<td>eg:192.168.12.134:10911</td>
<td>指定broker地址(与集群名称二选一)</td>
</tr>
<tr>
<td>g</td>
<td>eg:10.10.154.1,10.10.154.2</td>
<td>全局IP白名单(必填)</td>
</tr>
</tbody></table>
<h3 id="7-4-查询集群-x2F-Broker的ACL配置文件版本信息"><a href="#7-4-查询集群-x2F-Broker的ACL配置文件版本信息" class="headerlink" title="7.4 查询集群&#x2F;Broker的ACL配置文件版本信息"></a>7.4 查询集群&#x2F;Broker的ACL配置文件版本信息</h3><p>该命令的示例如下：</p>
<p>sh mqadmin clusterAclConfigVersion -n 192.168.1.2:9876 -c DefaultCluster</p>
<p>说明：如果指定的是集群名称，则会在集群中各个broker节点执行该命令；否则会在单个broker节点执行该命令。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>eg:192.168.1.2:9876</td>
<td>namesrv地址(必填)</td>
</tr>
<tr>
<td>c</td>
<td>eg:DefaultCluster</td>
<td>指定集群名称(与broker地址二选一)</td>
</tr>
<tr>
<td>b</td>
<td>eg:192.168.12.134:10911</td>
<td>指定broker地址(与集群名称二选一)</td>
</tr>
</tbody></table>
<p><strong>特别注意</strong>开启Acl鉴权认证后导致Master&#x2F;Slave和Dledger模式下Broker同步数据异常的问题，<br>在社区[4.5.1]版本中已经修复，具体的PR链接为：<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/pull/1149%EF%BC%9B">https://github.com/apache/rocketmq/pull/1149；</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/cn/msg_trace/user_guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/cn/msg_trace/user_guide/" class="post-title-link" itemprop="url">RocketMQ消息轨迹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:56:28" itemprop="dateModified" datetime="2025-04-26T20:56:28+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息轨迹"><a href="#消息轨迹" class="headerlink" title="消息轨迹"></a>消息轨迹</h1><hr>
<h2 id="1-消息轨迹数据关键属性"><a href="#1-消息轨迹数据关键属性" class="headerlink" title="1. 消息轨迹数据关键属性"></a>1. 消息轨迹数据关键属性</h2><table>
<thead>
<tr>
<th>Producer端</th>
<th>Consumer端</th>
<th>Broker端</th>
</tr>
</thead>
<tbody><tr>
<td>生产实例信息</td>
<td>消费实例信息</td>
<td>消息的Topic</td>
</tr>
<tr>
<td>发送消息时间</td>
<td>投递时间,投递轮次</td>
<td>消息存储位置</td>
</tr>
<tr>
<td>消息是否发送成功</td>
<td>消息是否消费成功</td>
<td>消息的Key值</td>
</tr>
<tr>
<td>发送耗时</td>
<td>消费耗时</td>
<td>消息的Tag值</td>
</tr>
</tbody></table>
<h2 id="2-支持消息轨迹集群部署"><a href="#2-支持消息轨迹集群部署" class="headerlink" title="2. 支持消息轨迹集群部署"></a>2. 支持消息轨迹集群部署</h2><h3 id="2-1-Broker端配置文件"><a href="#2-1-Broker端配置文件" class="headerlink" title="2.1 Broker端配置文件"></a>2.1 Broker端配置文件</h3><p>这里贴出Broker端开启消息轨迹特性的properties配置文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=0</span><br><span class="line">deleteWhen=04</span><br><span class="line">fileReservedTime=48</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">storePathRootDir=/data/rocketmq/rootdir-a-m</span><br><span class="line">storePathCommitLog=/data/rocketmq/commitlog-a-m</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">## if msg tracing is open,the flag will be true</span><br><span class="line">traceTopicEnable=true</span><br><span class="line">listenPort=10911</span><br><span class="line">brokerIP1=XX.XX.XX.XX1</span><br><span class="line">namesrvAddr=XX.XX.XX.XX:9876</span><br></pre></td></tr></table></figure>

<h3 id="2-2-普通模式"><a href="#2-2-普通模式" class="headerlink" title="2.2 普通模式"></a>2.2 普通模式</h3><p>RocketMQ集群中每一个Broker节点均用于存储Client端收集并发送过来的消息轨迹数据。因此，对于RocketMQ集群中的Broker节点数量并无要求和限制。</p>
<h3 id="2-3-物理IO隔离模式"><a href="#2-3-物理IO隔离模式" class="headerlink" title="2.3 物理IO隔离模式"></a>2.3 物理IO隔离模式</h3><p>对于消息轨迹数据量较大的场景，可以在RocketMQ集群中选择其中一个Broker节点专用于存储消息轨迹，使得用户普通的消息数据与消息轨迹数据的物理IO完全隔离，互不影响。在该模式下，RockeMQ集群中至少有两个Broker节点，其中一个Broker节点定义为存储消息轨迹数据的服务端。</p>
<h3 id="2-4-启动开启消息轨迹的Broker"><a href="#2-4-启动开启消息轨迹的Broker" class="headerlink" title="2.4 启动开启消息轨迹的Broker"></a>2.4 启动开启消息轨迹的Broker</h3><p><code>nohup sh mqbroker -c ../conf/2m-noslave/broker-a.properties &amp;</code></p>
<h2 id="3-保存消息轨迹的Topic定义"><a href="#3-保存消息轨迹的Topic定义" class="headerlink" title="3. 保存消息轨迹的Topic定义"></a>3. 保存消息轨迹的Topic定义</h2><p>RocketMQ的消息轨迹特性支持两种存储轨迹数据的方式：</p>
<h3 id="3-1-系统级的TraceTopic"><a href="#3-1-系统级的TraceTopic" class="headerlink" title="3.1 系统级的TraceTopic"></a>3.1 系统级的TraceTopic</h3><p>在默认情况下，消息轨迹数据是存储于系统级的TraceTopic中(其名称为：<strong>RMQ_SYS_TRACE_TOPIC</strong>)。该Topic在Broker节点启动时，会自动创建出来（如上所叙，需要在Broker端的配置文件中将<strong>traceTopicEnable</strong>的开关变量设置为<strong>true</strong>）。</p>
<h3 id="3-2-用户自定义的TraceTopic"><a href="#3-2-用户自定义的TraceTopic" class="headerlink" title="3.2 用户自定义的TraceTopic"></a>3.2 用户自定义的TraceTopic</h3><p>如果用户不准备将消息轨迹的数据存储于系统级的默认TraceTopic，也可以自己定义并创建用户级的Topic来保存轨迹（即为创建普通的Topic用于保存消息轨迹数据）。下面一节会介绍Client客户端的接口如何支持用户自定义的TraceTopic。</p>
<h2 id="4-支持消息轨迹的Client客户端实践"><a href="#4-支持消息轨迹的Client客户端实践" class="headerlink" title="4. 支持消息轨迹的Client客户端实践"></a>4. 支持消息轨迹的Client客户端实践</h2><p>为了尽可能地减少用户业务系统使用RocketMQ消息轨迹特性的改造工作量，作者在设计时候采用对原来接口增加一个开关参数(<strong>enableMsgTrace</strong>)来实现消息轨迹是否开启；并新增一个自定义参(<strong>customizedTraceTopic</strong>)数来实现用户存储消息轨迹数据至自己创建的用户级Topic。</p>
<h3 id="4-1-发送消息时开启消息轨迹"><a href="#4-1-发送消息时开启消息轨迹" class="headerlink" title="4.1 发送消息时开启消息轨迹"></a>4.1 发送消息时开启消息轨迹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;,true);</span><br><span class="line">producer.setNamesrvAddr(&quot;XX.XX.XX.XX1&quot;);</span><br><span class="line">producer.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Message msg = new Message(&quot;TopicTest&quot;,</span><br><span class="line">                &quot;TagA&quot;,</span><br><span class="line">                &quot;OrderID188&quot;,</span><br><span class="line">                &quot;Hello world&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-订阅消息时开启消息轨迹"><a href="#4-2-订阅消息时开启消息轨迹" class="headerlink" title="4.2 订阅消息时开启消息轨迹"></a>4.2 订阅消息时开启消息轨迹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;CID_JODIE_1&quot;,true);</span><br><span class="line">consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">consumer.setConsumeTimestamp(&quot;20181109221800&quot;);</span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">        System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);</span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.printf(&quot;Consumer Started.%n&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-支持自定义存储消息轨迹Topic"><a href="#4-3-支持自定义存储消息轨迹Topic" class="headerlink" title="4.3 支持自定义存储消息轨迹Topic"></a>4.3 支持自定义存储消息轨迹Topic</h3><p>在上面的发送和订阅消息时候分别将DefaultMQProducer和DefaultMQPushConsumer实例的初始化修改为如下即可支持自定义存储消息轨迹Topic。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##其中Topic_test11111需要用户自己预先创建，来保存消息轨迹；</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;,true,&quot;Topic_test11111&quot;);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;CID_JODIE_1&quot;,true,&quot;Topic_test11111&quot;);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/en/acl/Operations_ACL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/en/acl/Operations_ACL/" class="post-title-link" itemprop="url">RocketMQ Access control list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:58:31" itemprop="dateModified" datetime="2025-04-26T20:58:31+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Access-control-list"><a href="#Access-control-list" class="headerlink" title="Access control list"></a>Access control list</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>This document focuses on how to quickly deploy and use a RocketMQ cluster that supports the privilege control feature.</p>
<h2 id="1-Access-control-features"><a href="#1-Access-control-features" class="headerlink" title="1. Access control features"></a>1. Access control features</h2><p>Access Control (ACL) mainly provides Topic resource level user access control for RocketMQ.If you want to enable RocketMQ permission control, you can inject the AccessKey and SecretKey signatures through the RPCHook on the Client side.And then, the corresponding permission control attributes (including Topic access rights, IP whitelist and AccessKey and SecretKey signature) are set in the configuration file of distribution&#x2F;conf&#x2F;plain_acl.yml.The Broker side will check the permissions owned by the AccessKey, and if the verification fails, an exception is thrown;<br>The source code about ACL on the Client side can be find in <strong>org.apache.rocketmq.example.simple.AclClient.java</strong>  </p>
<h2 id="2-Access-control-definition-and-attribute-values"><a href="#2-Access-control-definition-and-attribute-values" class="headerlink" title="2. Access control definition and attribute values"></a>2. Access control definition and attribute values</h2><h3 id="2-1-Access-control-definition"><a href="#2-1-Access-control-definition" class="headerlink" title="2.1 Access control definition"></a>2.1 Access control definition</h3><p>The definition of Topic resource access control for RocketMQ is mainly as shown in the following table.</p>
<table>
<thead>
<tr>
<th>Permission</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>DENY</td>
<td>permission deny</td>
</tr>
<tr>
<td>ANY</td>
<td>PUB or SUB permission</td>
</tr>
<tr>
<td>PUB</td>
<td>Publishing permission</td>
</tr>
<tr>
<td>SUB</td>
<td>Subscription permission</td>
</tr>
</tbody></table>
<h3 id="2-2-Main-properties"><a href="#2-2-Main-properties" class="headerlink" title="2.2 Main properties"></a>2.2 Main properties</h3><table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>globalWhiteRemoteAddresses</td>
<td>string</td>
<td>Global IP whitelist,example:<br>*; <br>192.168.*.*; <br>192.168.0.1</td>
</tr>
<tr>
<td>accessKey</td>
<td>string</td>
<td>Access Key</td>
</tr>
<tr>
<td>secretKey</td>
<td>string</td>
<td>Secret Key</td>
</tr>
<tr>
<td>whiteRemoteAddress</td>
<td>string</td>
<td>User IP whitelist,example:<br>*; <br>192.168.*.*; <br>192.168.0.1</td>
</tr>
<tr>
<td>admin</td>
<td>true;false</td>
<td>Whether an administrator account</td>
</tr>
<tr>
<td>defaultTopicPerm</td>
<td>DENY;PUB;SUB;PUB|SUB</td>
<td>Default Topic permission</td>
</tr>
<tr>
<td>defaultGroupPerm</td>
<td>DENY;PUB;SUB;PUB|SUB</td>
<td>Default ConsumerGroup permission</td>
</tr>
<tr>
<td>topicPerms</td>
<td>topic&#x3D;permission</td>
<td>Topic only permission</td>
</tr>
<tr>
<td>groupPerms</td>
<td>group&#x3D;permission</td>
<td>ConsumerGroup only permission</td>
</tr>
</tbody></table>
<p>For details, please refer to the <strong>distribution&#x2F;conf&#x2F;plain_acl.yml</strong> configuration file.</p>
<h2 id="3-Cluster-deployment-with-permission-control"><a href="#3-Cluster-deployment-with-permission-control" class="headerlink" title="3. Cluster deployment with permission control"></a>3. Cluster deployment with permission control</h2><p>After defining the permission attribute in the <strong>distribution&#x2F;conf&#x2F;plain_acl.yml</strong> configuration file as described above, open the <strong>aclEnable</strong> switch variable to enable the ACL feature of the RocketMQ cluster.The configuration file of the ACL feature enabled on the broker is as follows:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/data/rocketmq/rootdir-a-m</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/data/rocketmq/commitlog-a-m</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## if acl is open,the flag will be true</span></span><br><span class="line"><span class="attr">aclEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="attr">brokerIP1</span>=<span class="string">XX.XX.XX.XX1</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">XX.XX.XX.XX:9876</span></span><br></pre></td></tr></table></figure>
<h2 id="4-Main-process-of-access-control"><a href="#4-Main-process-of-access-control" class="headerlink" title="4. Main process of access control"></a>4. Main process of access control</h2><p>The main ACL process is divided into two parts, including privilege resolution and privilege check.</p>
<h3 id="4-1-Privilege-resolution"><a href="#4-1-Privilege-resolution" class="headerlink" title="4.1 Privilege resolution"></a>4.1 Privilege resolution</h3><p>The Broker side parses the client’s RequestCommand request and obtains the attribute field that needs to be authenticated.<br>main attributes:<br> (1) AccessKey:Similar to the user name, on behalf of the user entity, the permission data corresponds to it;<br> (2) Signature:The client obtains the string according to the signature of the SecretKey, and the server uses the SecretKey to perform signature verification.</p>
<h3 id="4-2-Privilege-check"><a href="#4-2-Privilege-check" class="headerlink" title="4.2 Privilege check"></a>4.2 Privilege check</h3><p>The check logic of the right side of the broker is mainly divided into the following steps:<br> (1) Check if the global IP whitelist is hit; if yes, the check passes; otherwise, go to step (2);<br> (2) Check if the user IP whitelist is hit; if yes, the check passes; otherwise, go to step (3);<br> (3) Check the signature, if the verification fails, throw an exception; if the verification passes, go to step (4);<br> (4) Check the permissions required by the user request and the permissions owned by the user; if not, throw an exception;  </p>
<p>The verification of the required permissions of the user requires attention to the following points:<br> (1) Special requests such as UPDATE_AND_CREATE_TOPIC can only be operated by the admin account;<br> (2) For a resource, if there is explicit configuration permission, the configured permission is used; if there is no explicit configuration permission, the default permission is adopted;</p>
<h2 id="5-Hot-loading-modified-Access-control"><a href="#5-Hot-loading-modified-Access-control" class="headerlink" title="5. Hot loading modified Access control"></a>5. Hot loading modified Access control</h2><p>The default implementation of RocketrMQ’s permission control store is based on the yml configuration file. Users can dynamically modify the properties defined by the permission control without restarting the Broker service node.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://nydia.github.io/2022/10/01/rocketmq-docs/cn/client/java/API_Reference_DefaultMQProducer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nydia">
      <meta itemprop="description" content="开源，协作，共享，进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Talk is cheap,show me the code">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/rocketmq-docs/cn/client/java/API_Reference_DefaultMQProducer/" class="post-title-link" itemprop="url">RocketMQ DefaultMQProducer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-01 17:52:56" itemprop="dateCreated datePublished" datetime="2022-10-01T17:52:56+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-26 20:57:02" itemprop="dateModified" datetime="2025-04-26T20:57:02+08:00">2025-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="DefaultMQProducer"><a href="#DefaultMQProducer" class="headerlink" title="DefaultMQProducer"></a>DefaultMQProducer</h2><hr>
<h3 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h3><p><code>public class DefaultMQProducer  extends ClientConfig  implements MQProducer</code></p>
<blockquote>
<p><code>DefaultMQProducer</code>类是应用用来投递消息的入口，开箱即用，可通过无参构造方法快速创建一个生产者。主要负责消息的发送，支持同步&#x2F;异步&#x2F;oneway的发送方式，这些发送方式均支持批量发送。可以通过该类提供的getter&#x2F;setter方法，调整发送者的参数。<code>DefaultMQProducer</code>提供了多个send方法，每个send方法略有不同，在使用前务必详细了解其意图。下面给出一个生产者示例代码，<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/example/src/main/java/org/apache/rocketmq/example/">点击查看更多示例代码</a>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="comment">// 创建指定分组名的生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ProducerGroupName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 构建消息</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 同步发送</span></span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印发送结果</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该类是线程安全的。在配置并启动完成后可在多个线程间安全共享。</p>
<h3 id="字段摘要"><a href="#字段摘要" class="headerlink" title="字段摘要"></a>字段摘要</h3><table>
<thead>
<tr>
<th>类型</th>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DefaultMQProducerImpl</td>
<td>defaultMQProducerImpl</td>
<td>生产者的内部默认实现</td>
</tr>
<tr>
<td>String</td>
<td>producerGroup</td>
<td>生产者分组</td>
</tr>
<tr>
<td>String</td>
<td>createTopicKey</td>
<td>在发送消息时，自动创建服务器不存在的topic</td>
</tr>
<tr>
<td>int</td>
<td>defaultTopicQueueNums</td>
<td>创建topic时默认的队列数量</td>
</tr>
<tr>
<td>int</td>
<td>sendMsgTimeout</td>
<td>发送消息的超时时间</td>
</tr>
<tr>
<td>int</td>
<td>compressMsgBodyOverHowmuch</td>
<td>压缩消息体的阈值</td>
</tr>
<tr>
<td>int</td>
<td>retryTimesWhenSendFailed</td>
<td>同步模式下内部尝试发送消息的最大次数</td>
</tr>
<tr>
<td>int</td>
<td>retryTimesWhenSendAsyncFailed</td>
<td>异步模式下内部尝试发送消息的最大次数</td>
</tr>
<tr>
<td>boolean</td>
<td>retryAnotherBrokerWhenNotStoreOK</td>
<td>是否在内部发送失败时重试另一个broker</td>
</tr>
<tr>
<td>int</td>
<td>maxMessageSize</td>
<td>消息的最大长度</td>
</tr>
<tr>
<td>TraceDispatcher</td>
<td>traceDispatcher</td>
<td>消息追踪器。使用rcpHook来追踪消息</td>
</tr>
</tbody></table>
<h3 id="构造方法摘要"><a href="#构造方法摘要" class="headerlink" title="构造方法摘要"></a>构造方法摘要</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>DefaultMQProducer()</td>
<td>由默认参数值创建一个生产者</td>
</tr>
<tr>
<td>DefaultMQProducer(final String producerGroup)</td>
<td>使用指定的分组名创建一个生产者</td>
</tr>
<tr>
<td>DefaultMQProducer(final String producerGroup, boolean enableMsgTrace)</td>
<td>使用指定的分组名创建一个生产者，并设置是否开启消息追踪</td>
</tr>
<tr>
<td>DefaultMQProducer(final String producerGroup, boolean enableMsgTrace, final String customizedTraceTopic)</td>
<td>使用指定的分组名创建一个生产者，并设置是否开启消息追踪及追踪topic的名称</td>
</tr>
<tr>
<td>DefaultMQProducer(RPCHook rpcHook)</td>
<td>使用指定的hook创建一个生产者</td>
</tr>
<tr>
<td>DefaultMQProducer(final String producerGroup, RPCHook rpcHook)</td>
<td>使用指定的分组名及自定义hook创建一个生产者</td>
</tr>
<tr>
<td>DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,final String customizedTraceTopic)</td>
<td>使用指定的分组名及自定义hook创建一个生产者，并设置是否开启消息追踪及追踪topic的名称</td>
</tr>
</tbody></table>
<h3 id="使用方法摘要"><a href="#使用方法摘要" class="headerlink" title="使用方法摘要"></a>使用方法摘要</h3><table>
<thead>
<tr>
<th>返回值</th>
<th>方法名称</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>createTopic(String key, String newTopic, int queueNum)</td>
<td>在broker上创建指定的topic</td>
</tr>
<tr>
<td>void</td>
<td>createTopic(String key, String newTopic, int queueNum, int topicSysFlag)</td>
<td>在broker上创建指定的topic</td>
</tr>
<tr>
<td>long</td>
<td>earliestMsgStoreTime(MessageQueue mq)</td>
<td>查询最早的消息存储时间</td>
</tr>
<tr>
<td>List<MessageQueue></td>
<td>fetchPublishMessageQueues(String topic)</td>
<td>获取topic的消息队列</td>
</tr>
<tr>
<td>long</td>
<td>maxOffset(MessageQueue mq)</td>
<td>查询给定消息队列的最大offset</td>
</tr>
<tr>
<td>long</td>
<td>minOffset(MessageQueue mq)</td>
<td>查询给定消息队列的最小offset</td>
</tr>
<tr>
<td>QueryResult</td>
<td>queryMessage(String topic, String key, int maxNum, long begin, long end)</td>
<td>按关键字查询消息</td>
</tr>
<tr>
<td>long</td>
<td>searchOffset(MessageQueue mq, long timestamp)</td>
<td>查找指定时间的消息队列的物理offset</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Collection<Message> msgs)</td>
<td>同步批量发送消息</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Collection<Message> msgs, long timeout)</td>
<td>同步批量发送消息</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Collection<Message> msgs, MessageQueue messageQueue)</td>
<td>向指定的消息队列同步批量发送消息</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Collection<Message> msgs, MessageQueue messageQueue, long timeout)</td>
<td>向指定的消息队列同步批量发送消息，并指定超时时间</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg)</td>
<td>同步单条发送消息</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg, long timeout)</td>
<td>同步发送单条消息，并指定超时时间</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg, MessageQueue mq)</td>
<td>向指定的消息队列同步发送单条消息</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg, MessageQueue mq, long timeout)</td>
<td>向指定的消息队列同步单条发送消息，并指定超时时间</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, MessageQueue mq, SendCallback sendCallback)</td>
<td>向指定的消息队列异步单条发送消息，并指定回调方法</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, MessageQueue mq, SendCallback sendCallback, long timeout)</td>
<td>向指定的消息队列异步单条发送消息，并指定回调方法和超时时间</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg, MessageQueueSelector selector, Object arg)</td>
<td>向消息队列同步单条发送消息，并指定发送队列选择器</td>
</tr>
<tr>
<td>SendResult</td>
<td>send(Message msg, MessageQueueSelector selector, Object arg, long timeout)</td>
<td>向消息队列同步单条发送消息，并指定发送队列选择器与超时时间</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback)</td>
<td>向指定的消息队列异步单条发送消息</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback, long timeout)</td>
<td>向指定的消息队列异步单条发送消息，并指定超时时间</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, SendCallback sendCallback)</td>
<td>异步发送消息</td>
</tr>
<tr>
<td>void</td>
<td>send(Message msg, SendCallback sendCallback, long timeout)</td>
<td>异步发送消息，并指定回调方法和超时时间</td>
</tr>
<tr>
<td>TransactionSendResult</td>
<td>sendMessageInTransaction(Message msg, LocalTransactionExecuter tranExecuter, final Object arg)</td>
<td>发送事务消息，并指定本地执行事务实例</td>
</tr>
<tr>
<td>TransactionSendResult</td>
<td>sendMessageInTransaction(Message msg, Object arg)</td>
<td>发送事务消息</td>
</tr>
<tr>
<td>void</td>
<td>sendOneway(Message msg)</td>
<td>单向发送消息，不等待broker响应</td>
</tr>
<tr>
<td>void</td>
<td>sendOneway(Message msg, MessageQueue mq)</td>
<td>单向发送消息到指定队列，不等待broker响应</td>
</tr>
<tr>
<td>void</td>
<td>sendOneway(Message msg, MessageQueueSelector selector, Object arg)</td>
<td>单向发送消息到队列选择器的选中的队列，不等待broker响应</td>
</tr>
<tr>
<td>void</td>
<td>shutdown()</td>
<td>关闭当前生产者实例并释放相关资源</td>
</tr>
<tr>
<td>void</td>
<td>start()</td>
<td>启动生产者</td>
</tr>
<tr>
<td>MessageExt</td>
<td>viewMessage(String offsetMsgId)</td>
<td>根据给定的msgId查询消息</td>
</tr>
<tr>
<td>MessageExt</td>
<td>public MessageExt viewMessage(String topic, String msgId)</td>
<td>根据给定的msgId查询消息，并指定topic</td>
</tr>
</tbody></table>
<h3 id="字段详细信息"><a href="#字段详细信息" class="headerlink" title="字段详细信息"></a>字段详细信息</h3><ul>
<li><p><a target="_blank" rel="noopener" href="http://rocketmq.apache.org/docs/core-concept/">producerGroup</a></p>
<p>  <code>private String producerGroup</code></p>
<p>  生产者的分组名称。相同的分组名称表明生产者实例在概念上归属于同一分组。这对事务消息十分重要，如果原始生产者在事务之后崩溃，那么broker可以联系同一生产者分组的不同生产者实例来提交或回滚事务。</p>
<p>  默认值：DEFAULT_PRODUCER</p>
<p>  注意： 由数字、字母、下划线、横杠（-）、竖线（|）或百分号组成；不能为空；长度不能超过255。</p>
</li>
<li><p>defaultMQProducerImpl</p>
<p>  <code>protected final transient DefaultMQProducerImpl defaultMQProducerImpl</code></p>
<p>  生产者的内部默认实现，在构造生产者时内部自动初始化，提供了大部分方法的内部实现。</p>
</li>
<li><p>createTopicKey</p>
<p>  <code>private String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC</code></p>
<p>  在发送消息时，自动创建服务器不存在的topic，需要指定Key，该Key可用于配置发送消息所在topic的默认路由。</p>
<p>  默认值：TBW102</p>
<p>  建议：测试或者demo使用，生产环境下不建议打开自动创建配置。</p>
</li>
<li><p>defaultTopicQueueNums</p>
<p>  <code>private volatile int defaultTopicQueueNums = 4</code></p>
<p>  创建topic时默认的队列数量。</p>
<p>  默认值：4</p>
</li>
<li><p>sendMsgTimeout</p>
<p>  <code>private int sendMsgTimeout = 3000</code></p>
<p>  发送消息时的超时时间。</p>
<p>  默认值：3000，单位：毫秒 </p>
<p>  建议：不建议修改该值，该值应该与broker配置中的sendTimeout一致，发送超时，可临时修改该值，建议解决超时问题，提高broker集群的Tps。</p>
</li>
<li><p>compressMsgBodyOverHowmuch</p>
<p>  <code>private int compressMsgBodyOverHowmuch = 1024 * 4</code></p>
<p>  压缩消息体阈值。大于4K的消息体将默认进行压缩。</p>
<p>  默认值：1024 * 4，单位：字节</p>
<p>  建议：可通过DefaultMQProducerImpl.setZipCompressLevel方法设置压缩率（默认为5，可选范围[0,9]）；可通过DefaultMQProducerImpl.tryToCompressMessage方法测试出compressLevel与compressMsgBodyOverHowmuch最佳值。</p>
</li>
<li><p>retryTimesWhenSendFailed</p>
<p>  <code>private int retryTimesWhenSendFailed = 2</code></p>
<p>  同步模式下，在返回发送失败之前，内部尝试重新发送消息的最大次数。</p>
<p>  默认值：2，即：默认情况下一条消息最多会被投递3次。</p>
<p>  注意：在极端情况下，这可能会导致消息的重复。</p>
</li>
<li><p>retryTimesWhenSendAsyncFailed</p>
<p>  <code>private int retryTimesWhenSendAsyncFailed = 2</code></p>
<p>  异步模式下，在发送失败之前，内部尝试重新发送消息的最大次数。</p>
<p>  默认值：2，即：默认情况下一条消息最多会被投递3次。</p>
<p>  注意：在极端情况下，这可能会导致消息的重复。</p>
</li>
<li><p>retryAnotherBrokerWhenNotStoreOK</p>
<p>  <code>private boolean retryAnotherBrokerWhenNotStoreOK = false</code></p>
<p>  同步模式下，消息保存失败时是否重试其他broker。</p>
<p>  默认值：false</p>
<p>  注意：此配置关闭时，非投递时产生异常情况下，会忽略retryTimesWhenSendFailed配置。</p>
</li>
<li><p>maxMessageSize</p>
<p>  <code>private int maxMessageSize = 1024 * 1024 * 4</code></p>
<p>  消息的最大大小。当消息题的字节数超过maxMessageSize就发送失败。</p>
<p>  默认值：1024 * 1024 * 4，单位：字节</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/wiki/RIP-6-Message-Trace">traceDispatcher</a></p>
<p>  <code>private TraceDispatcher traceDispatcher = null</code></p>
<p>  在开启消息追踪后，该类通过hook的方式把消息生产者，消息存储的broker和消费者消费消息的信息像链路一样记录下来。在构造生产者时根据构造入参enableMsgTrace来决定是否创建该对象。</p>
</li>
</ul>
<h3 id="构造方法详细信息"><a href="#构造方法详细信息" class="headerlink" title="构造方法详细信息"></a>构造方法详细信息</h3><ol>
<li><p>DefaultMQProducer</p>
<p> <code>public DefaultMQProducer()</code></p>
<p> 创建一个新的生产者。</p>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(final String producerGroup)</code></p>
<p> 使用指定的分组名创建一个生产者。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>producerGroup</td>
<td>String</td>
<td>是</td>
<td>DEFAULT_PRODUCER</td>
<td>生产者的分组名称</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(final String producerGroup, boolean enableMsgTrace)</code></p>
<p> 使用指定的分组名创建一个生产者，并设置是否开启消息追踪。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>producerGroup</td>
<td>String</td>
<td>是</td>
<td>DEFAULT_PRODUCER</td>
<td>生产者的分组名称</td>
</tr>
<tr>
<td>enableMsgTrace</td>
<td>boolean</td>
<td>是</td>
<td>false</td>
<td>是否开启消息追踪</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(final String producerGroup, boolean enableMsgTrace, final String customizedTraceTopic)</code></p>
<p> 使用指定的分组名创建一个生产者，并设置是否开启消息追踪及追踪topic的名称。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>producerGroup</td>
<td>String</td>
<td>是</td>
<td>DEFAULT_PRODUCER</td>
<td>生产者的分组名称</td>
</tr>
<tr>
<td>rpcHook</td>
<td>RPCHook</td>
<td>否</td>
<td>null</td>
<td>每个远程命令执行后会回调rpcHook</td>
</tr>
<tr>
<td>enableMsgTrace</td>
<td>boolean</td>
<td>是</td>
<td>false</td>
<td>是否开启消息追踪</td>
</tr>
<tr>
<td>customizedTraceTopic</td>
<td>String</td>
<td>否</td>
<td>RMQ_SYS_TRACE_TOPIC</td>
<td>消息跟踪topic的名称</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(RPCHook rpcHook)</code></p>
<p> 使用指定的hook创建一个生产者。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>rpcHook</td>
<td>RPCHook</td>
<td>否</td>
<td>null</td>
<td>每个远程命令执行后会回调rpcHook</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(final String producerGroup, RPCHook rpcHook)</code></p>
<p> 使用指定的分组名及自定义hook创建一个生产者。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>producerGroup</td>
<td>String</td>
<td>是</td>
<td>DEFAULT_PRODUCER</td>
<td>生产者的分组名称</td>
</tr>
<tr>
<td>rpcHook</td>
<td>RPCHook</td>
<td>否</td>
<td>null</td>
<td>每个远程命令执行后会回调rpcHook</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>DefaultMQProducer</p>
<p> <code>DefaultMQProducer(final String producerGroup, RPCHook rpcHook, boolean enableMsgTrace,final String customizedTraceTopic)</code></p>
<p> 使用指定的分组名及自定义hook创建一个生产者，并设置是否开启消息追踪及追踪topic的名称。</p>
<ul>
<li>入参描述：</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>缺省值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>producerGroup</td>
<td>String</td>
<td>是</td>
<td>DEFAULT_PRODUCER</td>
<td>生产者的分组名称</td>
</tr>
<tr>
<td>rpcHook</td>
<td>RPCHook</td>
<td>否</td>
<td>null</td>
<td>每个远程命令执行后会回调rpcHook</td>
</tr>
<tr>
<td>enableMsgTrace</td>
<td>boolean</td>
<td>是</td>
<td>false</td>
<td>是否开启消息追踪</td>
</tr>
<tr>
<td>customizedTraceTopic</td>
<td>String</td>
<td>否</td>
<td>RMQ_SYS_TRACE_TOPIC</td>
<td>消息跟踪topic的名称</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="使用方法详细信息"><a href="#使用方法详细信息" class="headerlink" title="使用方法详细信息"></a>使用方法详细信息</h3><ol>
<li><p>createTopic</p>
<p><code>public void createTopic(String key, String newTopic, int queueNum)</code></p>
<p>在broker上创建一个topic。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>访问密钥。</td>
</tr>
<tr>
<td>newTopic</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>新建topic的名称。由数字、字母、下划线（_）、横杠（-）、竖线（&amp;#124;）或百分号（%）组成；<br>长度小于255；不能为TBW102或空。</td>
</tr>
<tr>
<td>queueNum</td>
<td>int</td>
<td>是</td>
<td>0</td>
<td>(0, maxIntValue]</td>
<td>topic的队列数量。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；未找到broker等客户端异常。</p>
</li>
</ul>
</li>
<li><p>createTopic</p>
<p><code>public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag)</code></p>
<p>在broker上创建一个topic。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>key</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>访问密钥。</td>
</tr>
<tr>
<td>newTopic</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>新建topic的名称。</td>
</tr>
<tr>
<td>queueNum</td>
<td>int</td>
<td>是</td>
<td>0</td>
<td>(0, maxIntValue]</td>
<td>topic的队列数量。</td>
</tr>
<tr>
<td>topicSysFlag</td>
<td>int</td>
<td>是</td>
<td>0</td>
<td></td>
<td>保留字段，暂未使用。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；未找到broker等客户端异常。</p>
</li>
</ul>
</li>
<li><p>earliestMsgStoreTime</p>
<p> <code>public long earliestMsgStoreTime(MessageQueue mq)</code></p>
<p> 查询最早的消息存储时间。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>要查询的消息队列</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  指定队列最早的消息存储时间。单位：毫秒。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常；线程中断等客户端异常。</p>
</li>
</ul>
</li>
<li><p>fetchPublishMessageQueues</p>
<p> <code>public List&lt;MessageQueue&gt; fetchPublishMessageQueues(String topic)</code></p>
<p> 获取topic的消息队列。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>topic</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>topic名称</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  传入topic下的消息队列。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常；线程中断等客户端异常。</p>
</li>
</ul>
</li>
<li><p>maxOffset</p>
<p> <code>public long maxOffset(MessageQueue mq)</code></p>
<p> 查询消息队列的最大物理偏移量。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>要查询的消息队列</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  给定消息队列的最大物理偏移量。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常；线程中断等客户端异常。</p>
</li>
</ul>
</li>
<li><p>minOffset</p>
<p> <code>public long minOffset(MessageQueue mq)</code></p>
<p> 查询给定消息队列的最小物理偏移量。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>要查询的消息队列</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  给定消息队列的最小物理偏移量。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常；线程中断等客户端异常。</p>
</li>
</ul>
</li>
<li><p>queryMessage</p>
<p> <code>public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)</code></p>
<p> 按关键字查询消息。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>topic</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>topic名称</td>
</tr>
<tr>
<td>key</td>
<td>String</td>
<td>否</td>
<td>null</td>
<td></td>
<td>查找的关键字</td>
</tr>
<tr>
<td>maxNum</td>
<td>int</td>
<td>是</td>
<td></td>
<td></td>
<td>返回消息的最大数量</td>
</tr>
<tr>
<td>begin</td>
<td>long</td>
<td>是</td>
<td></td>
<td></td>
<td>开始时间戳，单位：毫秒</td>
</tr>
<tr>
<td>end</td>
<td>long</td>
<td>是</td>
<td></td>
<td></td>
<td>结束时间戳，单位：毫秒</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  查询到的消息集合。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常等客户端异常客户端异常。<br><br>  InterruptedException - 线程中断。</p>
</li>
</ul>
</li>
<li><p>searchOffset</p>
<p> <code>public long searchOffset(MessageQueue mq, long timestamp)</code></p>
<p> 查找指定时间的消息队列的物理偏移量。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>要查询的消息队列。</td>
</tr>
<tr>
<td>timestamp</td>
<td>long</td>
<td>是</td>
<td></td>
<td></td>
<td>指定要查询时间的时间戳。单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  指定时间的消息队列的物理偏移量。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 生产者状态非Running；没有找到broker；broker返回失败；网络异常；线程中断等客户端异常。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p> <code>public SendResult send(Collection&lt;Message&gt; msgs)</code></p>
<p> 同步批量发送消息。在返回发送失败之前，内部尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendFailed</em>属性）。未明确指定发送队列，默认采取轮询策略发送。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msgs</td>
<td>Collection<Message></td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息集合。集合内的消息必须属同一个topic。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  批量消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Collection&lt;Message&gt; msgs, long timeout)</code></p>
<p>同步批量发送消息，如果在指定的超时时间内未完成消息投递，会抛出<em>RemotingTooMuchRequestException</em>。<br>在返回发送失败之前，内部尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendFailed</em>属性）。未明确指定发送队列，默认采取轮询策略发送。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msgs</td>
<td>Collection<Message></td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息集合。集合内的消息必须属同一个topic。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  批量消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Collection&lt;Message&gt; msgs, MessageQueue messageQueue)</code></p>
<p>向给定队列同步批量发送消息。</p>
<p>注意：指定队列意味着所有消息均为同一个topic。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msgs</td>
<td>Collection<Message></td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息集合。集合内的消息必须属同一个topic。</td>
</tr>
<tr>
<td>messageQueue</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。指定队列意味着待投递消息均为同一个topic。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  批量消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Collection&lt;Message&gt; msgs, MessageQueue messageQueue, long timeout)</code></p>
<p>向给定队列同步批量发送消息，如果在指定的超时时间内未完成消息投递，会抛出<em>RemotingTooMuchRequestException</em>。</p>
<p>注意：指定队列意味着所有消息均为同一个topic。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msgs</td>
<td>Collection<Message></td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息集合。集合内的消息必须属同一个topic。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
<tr>
<td>messageQueue</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。指定队列意味着待投递消息均为同一个topic。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  批量消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg)</code></p>
<p>以同步模式发送消息，仅当发送过程完全完成时，此方法才会返回。<br>在返回发送失败之前，内部尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendFailed</em>属性）。未明确指定发送队列，默认采取轮询策略发送。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg, long timeout)</code></p>
<p>以同步模式发送消息，如果在指定的超时时间内未完成消息投递，会抛出<em>RemotingTooMuchRequestException</em>。仅当发送过程完全完成时，此方法才会返回。<br>在返回发送失败之前，内部尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendFailed</em>属性）。未明确指定发送队列，默认采取轮询策略发送。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg, MessageQueue mq)</code></p>
<p>向指定的消息队列同步发送单条消息。仅当发送过程完全完成时，此方法才会返回。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg, MessageQueue mq, long timeout)</code></p>
<p>向指定的消息队列同步发送单条消息，如果在指定的超时时间内未完成消息投递，会抛出<em>RemotingTooMuchRequestException</em>。仅当发送过程完全完成时，此方法才会返回。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
<tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。指定队列意味着待投递消息均为同一个topic。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, MessageQueue mq, SendCallback sendCallback)</code></p>
<p>向指定的消息队列异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。指定队列意味着待投递消息均为同一个topic。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, MessageQueue mq, SendCallback sendCallback, long timeout)</code></p>
<p>向指定的消息队列异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>若在指定时间内消息未发送成功，回调方法会收到<em>RemotingTooMuchRequestException</em>异常。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：<br>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg, MessageQueueSelector selector, Object arg)</code></p>
<p>向通过<code>MessageQueueSelector</code>计算出的队列同步发送消息。</p>
<p>可以通过自实现<code>MessageQueueSelector</code>接口，将某一类消息发送至固定的队列。比如：将同一个订单的状态变更消息投递至固定的队列。</p>
<p>注意：此消息发送失败内部不会重试。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>selector</td>
<td>MessageQueueSelector</td>
<td>是</td>
<td></td>
<td></td>
<td>队列选择器。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>否</td>
<td></td>
<td></td>
<td>供队列选择器使用的参数对象。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public SendResult send(Message msg, MessageQueueSelector selector, Object arg, long timeout)</code></p>
<p>向通过<code>MessageQueueSelector</code>计算出的队列同步发送消息，并指定发送超时时间。</p>
<p>可以通过自实现<code>MessageQueueSelector</code>接口，将某一类消息发送至固定的队列。比如：将同一个订单的状态变更消息投递至固定的队列。</p>
<p>注意：此消息发送失败内部不会重试。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>selector</td>
<td>MessageQueueSelector</td>
<td>是</td>
<td></td>
<td></td>
<td>队列选择器。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>否</td>
<td></td>
<td></td>
<td>供队列选择器使用的参数对象。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  消息的发送结果，包含msgId，发送状态等信息。</p>
</li>
<li><p>异常描述：<br>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 发送线程中断。<br><br>  RemotingTooMuchRequestException - 发送超时。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback)</code></p>
<p>向通过<code>MessageQueueSelector</code>计算出的队列异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<p>可以通过自实现<code>MessageQueueSelector</code>接口，将某一类消息发送至固定的队列。比如：将同一个订单的状态变更消息投递至固定的队列。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>selector</td>
<td>MessageQueueSelector</td>
<td>是</td>
<td></td>
<td></td>
<td>队列选择器。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>否</td>
<td></td>
<td></td>
<td>供队列选择器使用的参数对象。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback, long timeout)</code></p>
<p>向通过<code>MessageQueueSelector</code>计算出的队列异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<p>可以通过自实现<code>MessageQueueSelector</code>接口，将某一类消息发送至固定的队列。比如：将同一个订单的状态变更消息投递至固定的队列。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>selector</td>
<td>MessageQueueSelector</td>
<td>是</td>
<td></td>
<td></td>
<td>队列选择器。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>否</td>
<td></td>
<td></td>
<td>供队列选择器使用的参数对象。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, SendCallback sendCallback)</code></p>
<p>异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>send</p>
<p><code>public void send(Message msg, SendCallback sendCallback, long timeout)</code></p>
<p>异步发送单条消息，异步发送调用后直接返回，并在在发送成功或者异常时回调<code>sendCallback</code>，所以异步发送时<code>sendCallback</code>参数不能为null，否则在回调时会抛出<code>NullPointerException</code>。<br>异步发送时，在成功发送前，其内部会尝试重新发送消息的最大次数（参见<em>retryTimesWhenSendAsyncFailed</em>属性）。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>sendCallback</td>
<td>SendCallback</td>
<td>是</td>
<td></td>
<td></td>
<td>回调接口的实现。</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>是</td>
<td>参见<em>sendMsgTimeout</em>属性</td>
<td></td>
<td>发送超时时间，单位：毫秒。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>sendMessageInTransaction</p>
<p><code>public TransactionSendResult sendMessageInTransaction(Message msg, LocalTransactionExecuter tranExecuter, final Object arg)</code></p>
<p>发送事务消息。该类不做默认实现，抛出<code>RuntimeException</code>异常。参见：<code>TransactionMQProducer</code>类。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的事务消息</td>
</tr>
<tr>
<td>tranExecuter</td>
<td><code>LocalTransactionExecuter</code></td>
<td>是</td>
<td></td>
<td></td>
<td>本地事务执行器。该类<em>已过期</em>，将在5.0.0版本中移除。请勿使用该方法。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>是</td>
<td></td>
<td></td>
<td>供本地事务执行程序使用的参数对象</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  事务结果，参见：<code>LocalTransactionState</code>类。</p>
</li>
<li><p>异常描述：</p>
<p>  RuntimeException - 永远抛出该异常。</p>
</li>
</ul>
</li>
<li><p>sendMessageInTransaction</p>
<p><code>public TransactionSendResult sendMessageInTransaction(Message msg, final Object arg)</code></p>
<p>发送事务消息。该类不做默认实现，抛出<code>RuntimeException</code>异常。参见：<code>TransactionMQProducer</code>类。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的事务消息</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>是</td>
<td></td>
<td></td>
<td>供本地事务执行程序使用的参数对象</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  事务结果，参见：<code>LocalTransactionState</code>类。</p>
</li>
<li><p>异常描述：</p>
<p>  RuntimeException - 永远抛出该异常。</p>
</li>
</ul>
</li>
<li><p>sendOneway</p>
<p><code>public void sendOneway(Message msg)</code></p>
<p>  以oneway形式发送消息，broker不会响应任何执行结果，和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>类似。它具有最大的吞吐量但消息可能会丢失。</p>
<p>  可在消息量大，追求高吞吐量并允许消息丢失的情况下使用该方式。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>sendOneway</p>
<p><code>public void sendOneway(Message msg, MessageQueue mq)</code></p>
<p>  向指定队列以oneway形式发送消息，broker不会响应任何执行结果，和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>类似。它具有最大的吞吐量但消息可能会丢失。</p>
<p>  可在消息量大，追求高吞吐量并允许消息丢失的情况下使用该方式。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息</td>
</tr>
<tr>
<td>mq</td>
<td>MessageQueue</td>
<td>是</td>
<td></td>
<td></td>
<td>待投递的消息队列</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：<br>  void</p>
</li>
<li><p>异常描述：<br>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>sendOneway</p>
<p><code>public void sendOneway(Message msg, MessageQueueSelector selector, Object arg)</code></p>
<p>  向通过<code>MessageQueueSelector</code>计算出的队列以oneway形式发送消息，broker不会响应任何执行结果，和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>类似。它具有最大的吞吐量但消息可能会丢失。</p>
<p>  可在消息量大，追求高吞吐量并允许消息丢失的情况下使用该方式。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msg</td>
<td>Message</td>
<td>是</td>
<td></td>
<td></td>
<td>待发送的消息。</td>
</tr>
<tr>
<td>selector</td>
<td>MessageQueueSelector</td>
<td>是</td>
<td></td>
<td></td>
<td>队列选择器。</td>
</tr>
<tr>
<td>arg</td>
<td>Object</td>
<td>否</td>
<td></td>
<td></td>
<td>供队列选择器使用的参数对象。</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - broker不存在或未找到；namesrv地址为空；未找到topic的路由信息等客户端异常。<br><br>  RemotingException - 网络异常。<br><br>  InterruptedException - 发送线程中断。</p>
</li>
</ul>
</li>
<li><p>shutdown</p>
<p><code>public void shutdown()</code></p>
<p>关闭当前生产者实例并释放相关资源。</p>
<ul>
<li><p>入参描述：</p>
<p>  无。</p>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
</li>
</ul>
</li>
<li><p>start</p>
<p><code>public void start()</code></p>
<p>启动生产者实例。在发送或查询消息之前必须调用此方法。它执行了许多内部初始化，比如：检查配置、与namesrv建立连接、启动一系列心跳等定时任务等。</p>
<ul>
<li><p>入参描述：</p>
<p>  无。</p>
</li>
<li><p>返回值描述：</p>
<p>  void</p>
</li>
<li><p>异常描述：</p>
<p>  MQClientException - 初始化过程中出现失败。</p>
</li>
</ul>
</li>
<li><p>viewMessage</p>
<p><code>public MessageExt viewMessage(String offsetMsgId)</code></p>
<p>根据给定的msgId查询消息。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>offsetMsgId</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>offsetMsgId</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  返回<code>MessageExt</code>，包含：topic名称，消息题，消息ID，消费次数，生产者host等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  RemotingException - 网络层发生错误。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 线程被中断。<br><br>  MQClientException - 生产者状态非Running；msgId非法等。</p>
</li>
</ul>
</li>
<li><p>viewMessage</p>
<p><code>public MessageExt viewMessage(String topic, String msgId)</code></p>
<p>根据给定的msgId查询消息，并指定topic。</p>
<ul>
<li><p>入参描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>是否必须</th>
<th>默认值</th>
<th>值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>msgId</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>msgId</td>
</tr>
<tr>
<td>topic</td>
<td>String</td>
<td>是</td>
<td></td>
<td></td>
<td>topic名称</td>
</tr>
</tbody></table>
</li>
<li><p>返回值描述：</p>
<p>  返回<code>MessageExt</code>，包含：topic名称，消息题，消息ID，消费次数，生产者host等信息。</p>
</li>
<li><p>异常描述：</p>
<p>  RemotingException - 网络层发生错误。<br><br>  MQBrokerException - broker发生错误。<br><br>  InterruptedException - 线程被中断。<br><br>  MQClientException - 生产者状态非Running；msgId非法等。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">nydia</p>
  <div class="site-description" itemprop="description">开源，协作，共享，进步</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nydia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
